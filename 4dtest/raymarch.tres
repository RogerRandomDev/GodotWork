[gd_resource type="ShaderMaterial" load_steps=4 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;

// Raymarching constants
const float SURFACE_DST = 0.01;
const int MAX_STEPS = 128;
const float MAX_DISTANCE = 1024f;
const float NORMAL_STEP = .001f;
uniform float CurrentW=0f;
uniform sampler2D Data;
uniform int DataSize;

///////////////////////
// Boolean Operators
///////////////////////
 
float intersectSDF(float distA, float distB) {
    return max(distA, distB);
}
 
float unionSDF(float distA, float distB) {
    return min(distA, distB);
}
 
float differenceSDF(float distA, float distB) {
    return max(distA, -distB);
}
float Booleans(int val,float ldst, float dst){
	if(val == 0){return dst;} 
	if(val == 1){return intersectSDF(ldst,dst);}
	if(val == 2){return unionSDF(ldst,dst);}
	if(val == 3){return differenceSDF(ldst,dst);}
}
vec4 getfD(vec3 p,vec3 Rot, vec3 WRot, vec4 WPos){
	vec4 p4d = vec4(p.x,p.y,p.z,CurrentW)-WPos;
	p4d.xz = p4d.xz*mat2(vec2(cos(Rot.y), sin(Rot.y)),vec2( -sin(Rot.y), cos(Rot.y)));
	p4d.yz = p4d.yz*mat2(vec2(cos(Rot.x), -sin(Rot.x)),vec2( sin(Rot.x), cos(Rot.x)));
	p4d.xy = p4d.xy*mat2(vec2(cos(Rot.z), -sin(Rot.z)),vec2( sin(Rot.z), cos(Rot.z)));

	p4d.xw = p4d.xw*mat2(vec2(cos(WRot.x), sin(WRot.x)), vec2(-sin(WRot.x), cos(WRot.x)));
	p4d.zw = p4d.zw*mat2(vec2(cos(WRot.z), -sin(WRot.z)), vec2(sin(WRot.z), cos(WRot.z)));
	p4d.yw = p4d.yw*mat2(vec2(cos(WRot.y), -sin(WRot.y)), vec2(sin(WRot.y), cos(WRot.y)));
	return p4d;
}
// Rotation matrix from angle
mat3 rotate(vec3 theta) {
    float cy = cos(theta.y);
    float sy = sin(theta.y);
	float cx = cos(theta.x);
	float sx = sin(theta.x);
	float cz = cos(theta.z);
	float sz = sin(theta.z);
    return mat3(
        vec3(cy+cz, sz, sy),
        vec3(-sz, 1.0+cx+cz, sx),
        vec3(-sy, -sx, cy+cx)
    );
}
float HyperHedron( vec3 p, vec4 size, vec3 rot, vec3 wrot, vec4 wpos)
{
	vec4 p4d = getfD(p, rot, wrot, wpos);
	p4d = abs(p4d);
	return (p4d.x+p4d.y+p4d.z+p4d.w-length(size))*0.57735027;
}
float HyperCube(vec3 p, vec4 size, vec3 rot, vec3 wrot, vec4 wpos){
	vec4 p4d = getfD(p, rot, wrot, wpos);
	vec4 d = abs(p4d)-(size+vec4(0,0,0,CurrentW));
	return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0));
}
float getshape(float start,vec3 pos){
	float dst = 0.0;
	vec4 Size = texture(Data,vec2(0.125,start)).rgba*255.0;
	vec4 WPosition = texture(Data,vec2(0.375,start)).rgba*255.0;
	vec3 Rotation = -texture(Data,vec2(0.625,start)).rgb*510.0;
	vec4 WRot = texture(Data,vec2(0.875,start)).rgba*255.0;
	vec3 WRotation = WRot.xyz;
	int chose = int(WRot.w);
	if(chose == 0){
		dst = HyperCube(pos,
		Size,
		Rotation,
		WRotation,
		WPosition);
	}
	if(chose == 1){
		dst = HyperHedron(pos,
		Size,
		Rotation,
		WRotation,
		WPosition);
	}
	return dst;
}
// Sample the whole scene, you can mix multiple shapes here
float Scene(vec3 pos,float W) {
	//Objects
	float dst = getshape(float((float(1)+0.5)/float(DataSize)),pos);
	float lastdst;
	int Boolean =-1;
	for(int i = 0; i<DataSize; i++){
		lastdst = dst;
		dst=min(dst,
		getshape(float((float(i)+0.5)/float(DataSize)),pos)
		);
		Boolean = int(texture(Data,vec2(0.625,float((float(i)+0.5)/float(DataSize)))).a*255.0);
		dst = max(Booleans(Boolean,lastdst,dst),dst);
	}
	//Returns distance between objects
	return dst;
}

// The actual raymarching function
float RayMarch(vec3 ro, vec3 rd,float W) {
	float d = 0f;
	vec3 pos;
	for (int i = 0; i < MAX_STEPS; i++) {
		W = length(pos)-length(ro + rd * d);
		pos = ro + rd * d;
		float sceneDst = Scene(pos,W);
		
		d += sceneDst;
		
		// Only stop if distance is higher than MAX_DISTANCE or sampled distance
		// is less that surface threshold
		if (d > MAX_DISTANCE || abs(sceneDst) <= SURFACE_DST) break;
	}
	return d;
}

// Sample the world normal in the contact position
vec3 Normal(vec3 pos,float W) {
	float d = Scene(pos,W);
	vec2 e = vec2(NORMAL_STEP, 0.0);
	vec3 n = d - vec3(
		Scene(pos - e.xyy, W),
		Scene(pos - e.yxy, W),
		Scene(pos - e.yyx, W));
	return normalize(n);
}

void fragment() {
	// Get the pixel world coordinates
	vec3 world = (CAMERA_MATRIX * vec4(VERTEX, 1.0)).xyz;
	// Get the camera position
	vec3 camera = (CAMERA_MATRIX * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
	// Raymarching direction
	vec3 dir = normalize(world - camera);
	
	// Starts just a bit off the mesh surface
	vec3 ro = world - dir * SURFACE_DST;
	float newW=CurrentW;
	vec3 rd = dir;
	
	// Raymarch
	float d = RayMarch(ro, rd,newW);
	// Set the world position from the raymarching output
	world = ro + rd * d;
	
	if (d >= MAX_DISTANCE) discard;
	
	// Samples world normal
	vec3 n = Normal(world,newW);
	// Set the local normal relative to the view
	NORMAL = (INV_CAMERA_MATRIX * vec4(n, 0f)).xyz;
	
	// Depth calculation, this makes possible for other meshes intersect
	// properly with the geometry
	vec4 ndc = PROJECTION_MATRIX * INV_CAMERA_MATRIX * vec4(world, 1f);
	float depth = (ndc.z / ndc.w) * .5f + .5f;
	DEPTH = depth;
}"

[sub_resource type="Image" id=2]
data = {
"data": PoolByteArray( 129, 128, 128, 60, 129, 128, 128, 60, 129, 128, 128, 60, 129, 128, 128, 59, 251, 250, 250, 62, 249, 248, 248, 62, 185, 184, 56, 63, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 129, 128, 128, 59, 129, 128, 128, 59, 129, 128, 128, 59, 129, 128, 128, 59, 253, 252, 252, 62, 130, 129, 1, 63, 186, 185, 57, 63, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 29, 160, 59, 197, 8, 20, 187, 81, 112, 117, 187, 0, 0, 0, 0 ),
"format": "RGBAFloat",
"height": 2,
"mipmaps": false,
"width": 4
}

[sub_resource type="ImageTexture" id=3]
image = SubResource( 2 )
size = Vector2( 4, 2 )

[resource]
shader = SubResource( 1 )
shader_param/CurrentW = 0.0
shader_param/DataSize = 2
shader_param/Data = SubResource( 3 )
